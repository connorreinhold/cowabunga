/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cyr7.parser;

import java_cup.runtime.*;
import cyr7.ast.*;
import java.util.List;
import java.util.LinkedList;

parser code {:
:};

action code {:
:}

/* define how to connect to the scanner! */
init with {:
:};

scan with {: 
	Symbol sym = getScanner().next_token();
 	return (sym != null) ? sym : getSymbolFactory().newSymbol("END_OF_FILE",EOF_sym()); 
:};

/* Terminals (tokens returned by the scanner). */


terminal IXI_FILE, XI_FILE;
// Punctuation
terminal IF, ELSE, RETURN, USE, WHILE, LENGTH;

// Identifier
terminal String ID;

// Types
terminal String TYPE_INT, TYPE_BOOL;

// Values
terminal String INT_LITERAL;
terminal String STRING_LITERAL;
terminal String CHAR_LITERAL;
terminal Boolean BOOL_LITERAL;

// Punctuation
terminal L_PAREN, R_PAREN, L_SQ_BRKT, R_SQ_BRKT, L_BRACE, R_BRACE;
terminal COLON, SEMICOLON, COMMA, UNDERSCORE;

// Operators
terminal ASSIGN,
         PLUS,
         MINUS,
         MULT,
         HIGH_MULT,
         DIVIDE,
         EQUALS,
         NOT_EQUALS,
         LT,
         LTE,
         GT,
         GTE,
         NEG_BOOL,
         REMAINDER,
         LOGICAL_AND,
         LOGICAL_OR;

// Program-wide
nonterminal ProgramNode program;

// Ixi program

nonterminal IxiProgramNode ixi_program;
nonterminal LinkedList<FunctionDeclNode> FunctionDeclList;
nonterminal FunctionDeclNode Statement;
nonterminal FunctionDeclNode FunctionDecl;
nonterminal StatementEnd;

nonterminal LinkedList<FunctionArgDeclNode> ArgDecl;
nonterminal LinkedList<FunctionArgDeclNode> ArgDeclList;

nonterminal LinkedList<TypeNode> ReturnType;
nonterminal LinkedList<TypeNode> ReturnTypeList;

nonterminal TypeNode Type;
nonterminal PrimitiveTypeNode Primitive;

// Xi program

nonterminal ExprNode XiProgram;

nonterminal ExprNode Expr;
nonterminal FunctionCallNode FunctionCall;
nonterminal LinkedList<ExprNode> ArgParamList;
nonterminal ExprNode LiteralExpr;

// Grammar

start with XiProgram;

program ::= IXI_FILE ixi_program:ixi {: RESULT = ixi; :};

// Ixi Grammar

ixi_program ::= FunctionDeclList:lst {: RESULT = new IxiProgramNode(lst); :};
FunctionDeclList ::= FunctionDeclList:lst Statement:stmt {: 
			lst.addLast(stmt);
			RESULT = lst;
		:}
					| {: RESULT = new LinkedList<>(); :}
					;
Statement ::= FunctionDecl:decl StatementEnd {:
			RESULT = decl;
		:};

FunctionDecl ::= ID:id L_PAREN ArgDecl:argList R_PAREN ReturnType:returnList {:
			RESULT = new FunctionDeclNode(id, argList, returnList);
		:};

StatementEnd ::= SEMICOLON
				| 
				;
ArgDecl ::= ID:id COLON Type:t ArgDeclList:lst {:
			lst.addFirst(new FunctionArgDeclNode(id, t));
			RESULT = lst;
		:}
		| {: RESULT = new LinkedList<>(); :}
		;
		
ArgDeclList ::= COMMA ID:id COLON Type:t ArgDeclList:lst {:
				lst.addFirst(new FunctionArgDeclNode(id, t));
				RESULT = lst; 
			:}
			| {: RESULT = new LinkedList<>(); :}
		  	;

ReturnType ::= COLON Type:t ReturnTypeList:lst {: lst.addFirst(t); RESULT = lst; :}
			|	{: RESULT = new LinkedList<>(); :} 
			;

ReturnTypeList ::= ReturnTypeList:lst COMMA Type:t {: lst.addLast(t); RESULT = lst; :}
				| {: RESULT = new LinkedList<>(); :}
				;

Type ::= Type:t L_SQ_BRKT R_SQ_BRKT {: RESULT = new ArrayTypeNode(t); :}
		| TYPE_INT {: RESULT = new PrimitiveTypeNode(PrimitiveEnum.INT); :} 
		| TYPE_BOOL {: RESULT = new PrimitiveTypeNode(PrimitiveEnum.BOOL); :};

// Xi Grammar

XiProgram ::= XI_FILE Expr:e {: RESULT = e; :}
    ;

Expr ::= FunctionCall:e {: RESULT = e; :}
    | LiteralExpr:e  {: RESULT = e; :}
    ;

FunctionCall ::= ID:id L_PAREN ArgParamList:l R_PAREN {: RESULT = new FunctionCallNode(id, l); :};

ArgParamList ::= Expr:e COMMA ArgParamList:l {: l.addLast(e); RESULT = l; :}
    | Expr:e {: RESULT = new LinkedList<>(List.of(e)); :}
    | {: RESULT = new LinkedList<>(); :}
    ;

LiteralExpr ::= INT_LITERAL:l {: RESULT = new LiteralIntExprNode(l); :}
    | CHAR_LITERAL:l {: RESULT = new LiteralCharExprNode(l); :}
    | STRING_LITERAL:l {: RESULT = new LiteralStringExprNode(l); :}
    ;