/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cyr7.parser;

import java_cup.runtime.*;
import cyr7.ast.*;
import cyr7.ast.binexpr.*;
import cyr7.ast.unaryexpr.*;
import java.util.List;
import java.util.LinkedList;

parser code {:
:};

action code {:
:}

/* define how to connect to the scanner! */
init with {:
:};

scan with {: 
    Symbol sym = getScanner().next_token();
    return (sym != null) ? sym : getSymbolFactory().newSymbol("END_OF_FILE",EOF_sym());
:};

/* Terminals (tokens returned by the scanner). */


terminal IXI_FILE, XI_FILE;
// Punctuation
terminal IF, ELSE, RETURN, USE, WHILE, LENGTH;

// Identifier
terminal String ID;

// Types
terminal String TYPE_INT, TYPE_BOOL;

// Values
terminal String INT_LITERAL;
terminal String STRING_LITERAL;
terminal String CHAR_LITERAL;
terminal Boolean BOOL_LITERAL;

// Punctuation
terminal L_PAREN, R_PAREN, L_SQ_BRKT, R_SQ_BRKT, L_BRACE, R_BRACE;
terminal COLON, SEMICOLON, COMMA, UNDERSCORE;

// Operators
terminal ASSIGN,
         PLUS,
         MINUS,
         MULT,
         HIGH_MULT,
         DIVIDE,
         EQUALS,
         NOT_EQUALS,
         LT,
         LTE,
         GT,
         GTE,
         NEG_BOOL,
         NEG_INT,
         REMAINDER,
         LOGICAL_AND,
         LOGICAL_OR
         ;

terminal FUNCTION_CALL,
         ARRAY_ACCESS;

// Program-wide
nonterminal ProgramNode program;

// Ixi program

nonterminal IxiProgramNode ixi_program;
nonterminal LinkedList<FunctionDeclNode> FunctionDeclList;
nonterminal FunctionDeclNode Statement;
nonterminal FunctionDeclNode FunctionDecl;
nonterminal StatementEnd;

nonterminal LinkedList<FunctionArgDeclNode> ArgDecl;
nonterminal LinkedList<FunctionArgDeclNode> ArgDeclList;

nonterminal LinkedList<TypeNode> ReturnType;
nonterminal LinkedList<TypeNode> ReturnTypeList;

nonterminal TypeNode Type;
nonterminal PrimitiveTypeNode Primitive;

// Xi program

nonterminal LinkedList<ExprNode> XiProgram;
nonterminal LinkedList<ExprNode> ExprList;

nonterminal ExprNode Expr;

nonterminal FunctionCallNode FunctionCall;
nonterminal LinkedList<ExprNode> ArgParamList;

nonterminal ArrayAccessNode ArrayAccess;

nonterminal ExprNode LiteralExpr;

nonterminal ExprNode UnaryExpr;

nonterminal ExprNode IntegerExpr;

nonterminal ExprNode BoolExpr;

// Precedence
precedence left LOGICAL_OR;
precedence left LOGICAL_AND;
precedence left EQUALS, NOT_EQUALS;
precedence left LT, LTE, GTE, GT;
precedence left PLUS, MINUS;
precedence left MULT, HIGH_MULT, DIVIDE, REMAINDER;
precedence nonassoc NEG_INT, NEG_BOOL;
precedence left FUNCTION_CALL, ARRAY_ACCESS;

// Grammar

start with XiProgram;

program ::=
    IXI_FILE ixi_program:ixi {: RESULT = ixi; :};

// Ixi Grammar

ixi_program ::=
    FunctionDeclList:lst {: RESULT = new IxiProgramNode(lst); :};

FunctionDeclList ::=
    FunctionDeclList:lst Statement:stmt {:
            lst.addLast(stmt);
            RESULT = lst;
        :}
    | {: RESULT = new LinkedList<>(); :}
;

Statement ::=
    FunctionDecl:decl StatementEnd {:
            RESULT = decl;
        :}
;

FunctionDecl ::=
    ID:id L_PAREN ArgDecl:argList R_PAREN ReturnType:returnList {:
            RESULT = new FunctionDeclNode(id, argList, returnList);
        :}
;

StatementEnd ::=
    SEMICOLON
    |
    ;

ArgDecl ::=
    ID:id COLON Type:t ArgDeclList:lst {:
            lst.addFirst(new FunctionArgDeclNode(id, t));
            RESULT = lst;
        :}
    | {: RESULT = new LinkedList<>(); :}
    ;

ArgDeclList ::=
    COMMA ID:id COLON Type:t ArgDeclList:lst {:
            lst.addFirst(new FunctionArgDeclNode(id, t));
            RESULT = lst;
        :}
    | {: RESULT = new LinkedList<>(); :}
    ;

ReturnType ::=
    COLON Type:t ReturnTypeList:lst {: lst.addFirst(t); RESULT = lst; :}
    | {: RESULT = new LinkedList<>(); :}
    ;

ReturnTypeList ::=
    ReturnTypeList:lst COMMA Type:t {: lst.addLast(t); RESULT = lst; :}
    | {: RESULT = new LinkedList<>(); :}
    ;

Type ::=
    Type:t L_SQ_BRKT R_SQ_BRKT {: RESULT = new ArrayTypeNode(t); :}
    | TYPE_INT {: RESULT = new PrimitiveTypeNode(PrimitiveEnum.INT); :}
    | TYPE_BOOL {: RESULT = new PrimitiveTypeNode(PrimitiveEnum.BOOL); :}
    ;

// Xi Grammar

XiProgram ::=
    XI_FILE ExprList:l {: RESULT = l; :}
    ;

ExprList ::=
    Expr:e SEMICOLON ExprList:l {: l.addLast(e); RESULT = l; :}
    | Expr:e {: RESULT = new LinkedList<>(List.of(e)); :}
    ;

Expr ::=
    FunctionCall:e {: RESULT = e; :}
    | ArrayAccess:e {: RESULT = e; :}
    | LiteralExpr:e  {: RESULT = e; :}
    | UnaryExpr:e {: RESULT = e; :}
    | IntegerExpr:e {: RESULT = e; :}
    | BoolExpr:e {: RESULT = e; :}
    ;

// For an explanation of %prec https://www.cs.princeton.edu/~appel/modern/java/CUP/manual.html#cpp
FunctionCall ::=
    ID:id L_PAREN ArgParamList:l R_PAREN {: RESULT = new FunctionCallNode(id, l); :} %prec FUNCTION_CALL
    ;

ArgParamList ::=
    Expr:e COMMA ArgParamList:l {: l.addLast(e); RESULT = l; :}
    | Expr:e {: RESULT = new LinkedList<>(List.of(e)); :}
    | {: RESULT = new LinkedList<>(); :}
    ;

ArrayAccess ::=
    ID:id L_SQ_BRKT Expr:e R_SQ_BRKT {: RESULT = new ArrayAccessNode(id, e); :} %prec ARRAY_ACCESS
    ;

LiteralExpr ::=
    INT_LITERAL:l {: RESULT = new LiteralIntExprNode(l); :}
    | CHAR_LITERAL:l {: RESULT = new LiteralCharExprNode(l); :}
    | STRING_LITERAL:l {: RESULT = new LiteralStringExprNode(l); :}
    ;

UnaryExpr ::=
    NEG_BOOL Expr:e {: RESULT = new BoolNegExprNode(e); :}
    | MINUS Expr:e {: RESULT = new IntNegExprNode(e); :} %prec NEG_INT
    ;

IntegerExpr ::=
    Expr:e1 MULT Expr:e2 {: RESULT = new MultExprNode(e1, e2); :}
    | Expr:e1 HIGH_MULT Expr:e2 {: RESULT = new HighMultExprNode(e1, e2); :}
    | Expr:e1 DIVIDE Expr:e2 {: RESULT = new DivExprNode(e1, e2); :}
    | Expr:e1 REMAINDER Expr:e2 {: RESULT = new RemExprNode(e1, e2); :}
    | Expr:e1 PLUS Expr:e2 {: RESULT = new AddExprNode(e1, e2); :}
    | Expr:e1 MINUS Expr:e2 {: RESULT = new SubExprNode(e1, e2); :}
    ;

BoolExpr ::=
    Expr:e1 LT Expr:e2 {: RESULT = new LTExprNode(e1, e2); :}
    | Expr:e1 LTE Expr:e2 {: RESULT = new LTEExprNode(e1, e2); :}
    | Expr:e1 GT Expr:e2 {: RESULT = new GTExprNode(e1, e2); :}
    | Expr:e1 GTE Expr:e2 {: RESULT = new GTEExprNode(e1, e2); :}
    | Expr:e1 EQUALS Expr:e2 {: RESULT = new EqualsExprNode(e1, e2); :}
    | Expr:e1 NOT_EQUALS Expr:e2 {: RESULT = new NotEqualsExprNode(e1, e2); :}
    | Expr:e1 LOGICAL_AND Expr:e2 {: RESULT = new AndExprNode(e1, e2); :}
    | Expr:e1 LOGICAL_OR Expr:e2 {: RESULT = new OrExprNode(e1, e2); :}
    ;
