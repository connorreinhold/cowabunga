/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cyr7.parser;

import java_cup.runtime.*;
import cyr7.ast.*;
import cyr7.ast.binexpr.*;
import cyr7.ast.unaryexpr.*;
import java.util.List;
import java.util.LinkedList;

parser code {:
:};

action code {:
:}

/* define how to connect to the scanner! */
init with {:
:};

scan with {: 
	Symbol sym = getScanner().next_token();
 	return (sym != null) ? sym : getSymbolFactory().newSymbol("END_OF_FILE",EOF_sym()); 
:};

/* Terminals (tokens returned by the scanner). */


terminal IXI_FILE, XI_FILE;
// Punctuation
terminal IF, ELSE, RETURN, USE, WHILE, LENGTH;

// Identifier
terminal String ID;

// Types
terminal String TYPE_INT, TYPE_BOOL;

// Values
terminal String INT_LITERAL;
terminal String STRING_LITERAL;
terminal String CHAR_LITERAL;
terminal Boolean BOOL_LITERAL;

// Punctuation
terminal L_PAREN, R_PAREN, L_SQ_BRKT, R_SQ_BRKT, L_BRACE, R_BRACE;
terminal COLON, SEMICOLON, COMMA, UNDERSCORE;

// Operators
terminal ASSIGN,
         PLUS,
         MINUS,
         MULT,
         HIGH_MULT,
         DIVIDE,
         EQUALS,
         NOT_EQUALS,
         LT,
         LTE,
         GT,
         GTE,
         NEG_BOOL,
         NEG_INT,
         REMAINDER,
         LOGICAL_AND,
         LOGICAL_OR
         ;

terminal FUNCTION_CALL,
         ARRAY_ACCESS;

// Program-wide
nonterminal ProgramNode program;

// Ixi program

nonterminal IxiProgramNode ixi_program;
nonterminal LinkedList<FunctionDeclNode> FunctionDeclList;
nonterminal FunctionDeclNode Statement;
nonterminal FunctionDeclNode FunctionDecl;
nonterminal StatementEnd;

nonterminal LinkedList<FunctionArgDeclNode> ArgDecl;
nonterminal LinkedList<FunctionArgDeclNode> ArgDeclList;

nonterminal LinkedList<TypeNode> ReturnType;
nonterminal LinkedList<TypeNode> ReturnTypeList;

nonterminal TypeNode Type;
nonterminal PrimitiveTypeNode Primitive;

// Xi program

nonterminal LinkedList<ExprNode> XiProgram;
nonterminal LinkedList<ExprNode> ExprList;

nonterminal ExprNode Expr;

nonterminal FunctionCallNode FunctionCall;
nonterminal LinkedList<ExprNode> ArgParamList;

nonterminal ArrayAccessNode ArrayAccess;

nonterminal ExprNode LiteralExpr;

nonterminal ExprNode UnaryExpr;

nonterminal ExprNode IntegerExpr;

nonterminal ExprNode BoolExpr;

// Precedence

precedence left PLUS, MINUS;
precedence left MULT, HIGH_MULT, DIVIDE, REMAINDER;
precedence left NEG_INT, NEG_BOOL;
precedence left FUNCTION_CALL, ARRAY_ACCESS;

// Grammar

start with XiProgram;

program ::= IXI_FILE ixi_program:ixi {: RESULT = ixi; :};

// Ixi Grammar

ixi_program ::= FunctionDeclList:lst {: RESULT = new IxiProgramNode(lst); :};
FunctionDeclList ::= FunctionDeclList:lst Statement:stmt {: 
			lst.addLast(stmt);
			RESULT = lst;
		:}
					| {: RESULT = new LinkedList<>(); :}
					;
Statement ::= FunctionDecl:decl StatementEnd {:
			RESULT = decl;
		:};

FunctionDecl ::= ID:id L_PAREN ArgDecl:argList R_PAREN ReturnType:returnList {:
			RESULT = new FunctionDeclNode(id, argList, returnList);
		:};

StatementEnd ::= SEMICOLON
				| 
				;
ArgDecl ::= ID:id COLON Type:t ArgDeclList:lst {:
			lst.addFirst(new FunctionArgDeclNode(id, t));
			RESULT = lst;
		:}
		| {: RESULT = new LinkedList<>(); :}
		;
		
ArgDeclList ::= COMMA ID:id COLON Type:t ArgDeclList:lst {:
				lst.addFirst(new FunctionArgDeclNode(id, t));
				RESULT = lst; 
			:}
			| {: RESULT = new LinkedList<>(); :}
		  	;

ReturnType ::= COLON Type:t ReturnTypeList:lst {: lst.addFirst(t); RESULT = lst; :}
			|	{: RESULT = new LinkedList<>(); :} 
			;

ReturnTypeList ::= ReturnTypeList:lst COMMA Type:t {: lst.addLast(t); RESULT = lst; :}
				| {: RESULT = new LinkedList<>(); :}
				;

Type ::= Type:t L_SQ_BRKT R_SQ_BRKT {: RESULT = new ArrayTypeNode(t); :}
		| TYPE_INT {: RESULT = new PrimitiveTypeNode(PrimitiveEnum.INT); :} 
		| TYPE_BOOL {: RESULT = new PrimitiveTypeNode(PrimitiveEnum.BOOL); :};

// Xi Grammar

XiProgram ::= XI_FILE ExprList:l {: RESULT = l; :}
    ;

ExprList ::= Expr:e SEMICOLON ExprList:l {: l.addLast(e); RESULT = l; :}
    | Expr:e {: RESULT = new LinkedList<>(List.of(e)); :}
    ;

Expr ::= FunctionCall:e {: RESULT = e; :}
    | ArrayAccess:e {: RESULT = e; :}
    | LiteralExpr:e  {: RESULT = e; :}
    | UnaryExpr:e {: RESULT = e; :}
    | IntegerExpr:e {: RESULT = e; :}
    | BoolExpr:e {: RESULT = e; :}
    ;

// For an explanation of %prec https://www.cs.princeton.edu/~appel/modern/java/CUP/manual.html#cpp
FunctionCall ::= ID:id L_PAREN ArgParamList:l R_PAREN {: RESULT = new FunctionCallNode(id, l); :} %prec FUNCTION_CALL
    ;

ArgParamList ::= Expr:e COMMA ArgParamList:l {: l.addLast(e); RESULT = l; :}
    | Expr:e {: RESULT = new LinkedList<>(List.of(e)); :}
    | {: RESULT = new LinkedList<>(); :}
    ;

ArrayAccess ::= ID:id L_SQ_BRKT Expr:e R_SQ_BRKT {: RESULT = new ArrayAccessNode(id, e); :} %prec ARRAY_ACCESS
    ;

LiteralExpr ::= INT_LITERAL:l {: RESULT = new LiteralIntExprNode(l); :}
    | CHAR_LITERAL:l {: RESULT = new LiteralCharExprNode(l); :}
    | STRING_LITERAL:l {: RESULT = new LiteralStringExprNode(l); :}
    ;

UnaryExpr ::= NEG_BOOL Expr:e {: RESULT = new BoolNegExprNode(e); :}
    | MINUS Expr:e {: RESULT = new IntNegExprNode(e); :} %prec NEG_INT
    ;

IntegerExpr ::= Expr:e1 MULT Expr:e2 {: RESULT = new MultExprNode(e1, e2); :}
    | Expr:e1 HIGH_MULT Expr:e2 {: RESULT = new HighMultExprNode(e1, e2); :}
    | Expr:e1 DIVIDE Expr:e2 {: RESULT = new DivExprNode(e1, e2); :}
    | Expr:e1 REMAINDER Expr:e2 {: RESULT = new RemExprNode(e1, e2); :}
    | Expr:e1 PLUS Expr:e2 {: RESULT = new AddExprNode(e1, e2); :}
    | Expr:e1 MINUS Expr:e2 {: RESULT = new SubExprNode(e1, e2); :}
    ;

